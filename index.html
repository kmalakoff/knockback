<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><title>Knockback</title><link rel="stylesheet" href="look.css"><link rel="stylesheet" href="lib/highlight/highlightjs/styles/dark.css"><script type="application/javascript" src="lib/highlight/highlightjs/highlight.js"></script><script type="application/javascript" src="lib/highlight/highlightjs/languages/javascript.js"></script><script type="application/javascript" src="lib/highlight/highlight-coffee.js"></script><script type="application/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js"></script><script type="application/javascript" src="interface.js"></script><script type="application/javascript">hljs.tabReplace = '  ';
hljs.initHighlightingOnLoad();
</script></head><body><div id="wrap"><header id="header"><div class="lock"><div class="logo"><div class="part left animated fadeInRight"><img src="lib/left.svg"></div><div class="part right animated fadeInLeft"><img src="lib/right.svg"></div></div><h1><span class="knock animated fadeInRight">Knock</span><span class="back animated fadeInLeft">back</span></h1></div><h2><span class="knock animated fadeIn">brings Knockout.js </span><span class="magic animated fadeIn">magic </span><span class="back animated fadeIn">to Backbone</span></h2></header><!--<nav id="navigation"><div class="separator"><span class="label">Code</span><div class="selection codestyle"><div class="option"><input id="cs-cs" type="radio" name="codestyle" value="cs" class="auto"><label for="cs-cs">CoffeeScript</label></div><div class="option"><input id="cs-js" type="radio" name="codestyle" value="js"><label for="cs-js">Javascript</label></div></div></div><div class="separator"><span class="label">Langauge</span><div class="selection codestyle"><div class="option"><input id="lang-en" type="radio" name="lang" checked><label for="lang-en">EN</label></div><div class="option"><input id="lang-fr" type="radio" name="lang"><label for="lang-fr">FR</label></div><div class="option"><input id="lang-it" type="radio" name="lang"><label for="lang-it">IT</label></div></div></div></nav>--><section id="content" class="animated fadeIn"><div class="cols wrapped"><div class="col"><div class="content"><h2>Dependencies</h2><p>Knockback requires Backbone (and therefore Underscore.js) and Knockout.js
to be already loaded on the page. Backbone.ModelRef is optional for lazy
model loading scenarios.
</p></div></div><div class="col"><div class="content"><h2>Features</h2><ul><li>Localization</li><li>Knockout.js' bindings and automagical update</li><li>Backbone's sleek Model definition</li><li>Dynamic collection sorting</li><li>Two-way string formatting</li></ul></div></div><div class="col"><div class="content"><h2>Latest <small>0.12</small></h2><ul><li><a href="https://raw.github.com/kmalakoff/knockback/0.12.0/knockback.js">Development</a> <small>45 KB</small></li><li><a href="https://raw.github.com/kmalakoff/knockback/0.12.0/knockback.min.js">Production</a> <small>28 KB</small></li></ul><h2>Source</h2><p>You can find the source on <a href="https://github.com/kmalakoff/knockback">Github</a>. To provide feedback leave a message
or <a href="https://github.com/kmalakoff/knockback/issues">create an issue</a>.</p></div></div></div><!--<div class="content"><h2>Some background</h2><p>Both Knockout and Backbone have their strengths and weaknesses, but together they are amazing!</p><p>At the same time you can have the strong ORM provided by Backbone and the dynamic view-models that Knockout.js offers.</p></div>--><div class="content"><table class="comparison"><col><col class="mid"><col><col class="ref"><thead><tr><th>Backbone</th><th class="kb mid">Knockback</th><th>Knockout.js</th><th title="Notes">!</th></tr></thead><tbody><tr><td class="yes">Bullet-proof ORM</td><td class="done">&#9754;</td><td class="no">Weak ORM</td><td class="hidden"></td></tr><tr><td class="yes">Built-in Serialization / Deserialization</td><td class="done">&#9754;</td><td class="no">Manual serialization</td><td class="ref"><a title="View description" href="#comparison-1">1</a></td></tr><tr><td class="no"><abbr title="Model/View/Controller">MVC</abbr></td><td class="done">&#9755;</td><td class="yes"><abbr title="Model/View/ViewModel">MVVM</abbr></td><td class="hidden"></td></tr><tr><td class="no">Low level DOM maninulation</td><td class="done">&#9755;</td><td class="yes">Reduced jQuery effort</td><td class="hidden"></td></tr><tr><td class="no">Manual view updating</td><td class="done">&#9755;</td><td class="yes"><code>data-bind</code> based sorcery</td><td class="hidden"></td></tr><tr><td class="yes">Routing and history support</td><td class="done">&#9754;</td><td class="no">No routing</td><td class="ref"><a title="View description" href="#comparison-2">2</a></td></tr><tr><td class="no">Blurred separation between: <br> Views | Controllers</td><td class="own">Proper separation between: <br> Models | Views | Controllers (ViewModels)</td><td class="no">Blurred separation between: <br> Models | Controllers (ViewModels)</td><td class="ref"><a title="View description" href="#comparison-3">3</a></td></tr><tr><td class="hidden"></td><td class="own dependent">Cross-view Model state synchronization</td><td class="hidden"></td><td class="hidden"></td></tr><tr><td class="no">Messy collection/view updating</td><td class="own">Fully sorted and updated collection views</td><td class="hidden"></td><td class="hidden"></td></tr><tr><td class="hidden"></td><td class="own">View settings and control properties</td><td class="hidden"></td><td class="ref"><a title="View description" href="#comparison-4">4</a></td></tr><tr><td class="hidden"></td><td class="own dependent">Localization</td><td class="hidden"></td><td class="hidden"></td></tr></tbody></table></div><div class="content notes"><h2>Notes</h2><section><div id="comparison-1"><h1>Serialization</h1>

<p>As you probably know, Backbone is known to have a fantastic syncing system built
as close as possible to the RESTful pattern. And if this is not good for your
application you can always opt to build a custom <code>Backbone.sync</code> or, if further
granularity is required, you can customize a Model/Collection&#39;s own <code>sync</code> function.</p>

<p>Knockout.js instead does not provide such a feature, and what it offers is a simple
plugin to map into/from any JSON source.</p>

<p>Knockback uses Backbone&#39;s models and collections, and this means that all the
serialization features we all love are still there!</p></div><div id="comparison-2"><h1>Routing</h1>

<p>In Knockback, while using Knockout.js ViewModel pattern, we developed a full
pattern that supports Backbone&#39;s routing solution.</p></div></section><section><div id="comparison-3"><h1>(Im)proper use of tools</h1>

<p>Too often, in a large Backbone application you find yourself building up views
with too much logic in them, almost always requiring sub-state management. This is
actually an improper use of views, which should be as logic-less as possible.</p>

<p>But you <em>have</em> to do things like that, and Backbone doesn&#39;t help the developer
solving this (ethical?) issue.</p>

<p>In Knockout.js, this is not a problem, because ViewModels differ from Views
exactly in this: they own states, methods and properties allowing the <em>views</em> to
be logic-less.</p>

<p>So Knockout solves the blurry View/Controller issue you&#39;ll find building large
applications with Backbone. <strong>But</strong> because Knockout simply provides ViewModels and no
Models, how can you build a proper MVC/MVVM? <em>Backbone to the rescue!</em></p>

<p>And the circle is complete: Models from Backbone, and Views/ViewModels from
Knockout.js.</p></div></section><section><div id="comparison-4"><h1>Views&#39; settings</h1>

<p>Following MVVM principles where a ViewModel is the "View&#39;s Model", and therefore
owns its own properties and methods which are <em>then</em> reflected in the View
itself, Knockback ViewModels can add View setting and control properties, which are not
(and should not be!) owned by the model.</p>

<p>What does this allow? Actual settings (<em>eg</em> colors for different priorities in a
task list) to be applied on all the associated ViewModels, or...something more
interesting, like an design pattern for localization.</p>

<p>If you consider localized labels as observed properties, then you can understand
how Knockback provides internationalization to your applications.</p></div></section></div><!--<div class="content"><h2>An example</h2><pre data-for="cs" class="hl"><code class="coffee">ContactViewModel = (model) ->
  kb.observables(model, {
    name:  {key:'name'}
    email: {key:'email', write: true, default: 'your.name@yourplace.com'}
    date:  {key:'date', write: true, localizer: LongDateLocalizer}
  }, this)
  return @
# Cool, isn't it?
</code></pre><pre data-for="js" class="hl"><code class="javascript">var ContactViewModel = function (model) {
  kb.observables(model, {
    name:  {key:'name'},
    email: {key:'email', write: true, default: 'your.name@yourplace.com'},
    date:  {key:'date', write: true, localizer: LongDateLocalizer } },
  }, this);
  return this;
};
// Cool, isn't it?
</code></pre><p>Contenuto</p></div>--></section><footer><p><em>Knockback</em> is brought you by <a href="https://github.com/kmalakoff">Kevin Malakoff</a></p>

<p>Designed by <a href="https://github.com/yuchi">Pier Paolo Ramon</a></p></footer></div><a href="https://github.com/kmalakoff/knockback"><img style="position:absolute; top:0; right:0; border:0; z-index:9999;" src="https://a248.e.akamai.net/assets.github.com/img/7afbc8b248c68eb468279e8c17986ad46549fb71/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub"></a></body></html>