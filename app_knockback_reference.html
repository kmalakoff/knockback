<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knockback.js Reference App</title>
    <link rel="stylesheet" href="vendor/css/normalize.css">
    <link rel="stylesheet" href="vendor/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="vendor/bootstrap/css/bootstrap-responsive.min.css">
    <link rel="stylesheet" href="vendor/google-code-prettify/prettify.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/layout_components.css">
    <link rel="icon" href="favicon.ico">
    <script type="application/javascript" src="vendor/js/jquery-1.9.1.js"></script>
    <link rel="stylesheet" href="css/tutorial.css">
    <script type="application/javascript" src="vendor/globalize/globalize.js"></script>
    <script type="application/javascript" src="vendor/globalize/globalize.culture.en-GB.js"></script>
    <script type="application/javascript" src="vendor/globalize/globalize.culture.fr-FR.js"></script>
    <script type="application/javascript" src="vendor/js/knockback-full-stack-0.17.2.js"></script>
    <script type="application/javascript" src="vendor/bootstrap/js/bootstrap.min.js"></script>
    <script type="application/javascript" src="vendor/google-code-prettify/prettify.js"></script>
    <script type="application/javascript" src="js/stylecode.js"></script>
    <script type="application/javascript" src="js/interface.js"></script>
  </head>
  <body>
    <div class="page navbar">
      <div class="navbar navbar-inverse navbar-fixed-top">
        <div class="navbar-inner">
          <div class="container"><a data-toggle="collapse" data-target=".nav-collapse" class="btn btn-navbar"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></a><a href="https://github.com/kmalakoff/knockback" class="brand kb">Knockback.js</a>
            <div class="nav-collapse">
              <ul class="nav">
                <li><a href="index.html">Home</a></li>
                <li><a href="doc/index.html">API</a></li>
                <li class="dropdown"><a href="#" data-toggle="dropdown" class="dropdown-toggle">Getting Started<b class="caret"></b></a>
                  <ul role="menu" class="dropdown-menu">
                    <li><a href="getting_started_introduction.html">Overview</a><a href="getting_started_dependent_library_basics.html">Dependent Library Basics</a><a href="getting_started_knockback_basics.html">Knockback Basics</a><a href="getting_started_views_view_models_models.html">Models, Views, and ViewModels</a><a href="getting_started_memory_lifecycle_management.html">Memory and Lifecycle Management</a><a href="getting_started_knockback_important_details.html">Knockback Important Details</a>
                    </li>
                  </ul>
                </li>
                <li class="dropdown"><a href="#" data-toggle="dropdown" class="dropdown-toggle">Components<b class="caret"></b></a>
                  <ul role="menu" class="dropdown-menu">
                    <li><a href="components_backbone_relational.html">Backbone Relational</a><a href="components_backbone_modelref.html">Backbone ModelRef</a><a href="components_knockback_inspector.html">Knockback Inspector</a><a href="components_knockback_navigators.html">Knockback Navigators</a>
                    </li>
                  </ul>
                </li>
                <li class="dropdown"><a href="#" data-toggle="dropdown" class="dropdown-toggle">Applications<b class="caret"></b></a>
                  <ul role="menu" class="dropdown-menu">
                    <li><a href="app_knockback_reference.html">Knockback Reference App</a><a href="app_todos.html">Todos App</a>
                    </li>
                  </ul>
                </li>
                <li class="dropdown"><a href="#" data-toggle="dropdown" class="dropdown-toggle">Tutorials<b class="caret"></b></a>
                  <ul role="menu" class="dropdown-menu">
                    <li><a href="tutorials_introduction.html">Introduction</a><a href="tutorial_kb_observable.html">kb.Observable</a><a href="tutorial_kb_view_model.html">kb.ViewModel</a><a href="tutorial_kb_collection_observable.html">kb.CollectionObservable</a><a href="tutorial_nested_models.html">Nested Models</a><a href="tutorial_relational_models.html">Relational Models</a><a href="tutorial_kb_localized_observable.html">kb.LocalizedObservable</a><a href="tutorial_locale_manager.html">Custom Locale Manager</a><a href="tutorial_inject.html">ViewModel Injection</a><a href="tutorial_knockback_inspector.html">Knockback Inspector (Advanced)</a>
                    </li>
                  </ul>
                </li>
                <li><a href="https://github.com/kmalakoff/knockback/blob/master/RELEASE_NOTES.md">Release Notes</a></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="container">
      <header class="page">
      </header>
      <content class="page">
        <section><h1>Knockback.js Reference App</h1>
<p><a href="http://kmalakoff.github.com/knockback-reference-app">Try the demo</a></p>
<h2>Combining Backbone.js and Knockout.js with Knockback.js</h2>
<p>As you should see by now, Backbone.js provides great models and collections ORM functionality plus single-page app routing,  Knockout.js provides very dynamic bindings between data and views using ViewModels, and Knockback.js provides the layer between the Backbone ORM and Knockout.js ViewModels.</p>
<p>Because Backbone.Views and Knockout.js ViewModels provide traditional MVC Controller functionality, it is your choice on how to structure your application and whether your continue to use Backbone.Views (personally, I no longer use Backbone.Views).</p>
<p>That said, I have put together a reference application that demonstrates some good principles for routing, memory management, and architectural structure. Let&#39;s get started!</p>
<h1>Memory Management</h1>
<p>Knockback.js requires you to release your view models using &#39;kb.release(view_model)&#39;. The reason for this is that kb.CollectionObservables and kb.ViewModels may have cicular references that need to be broken. Also, kb.release walks your ViewModel properties so it ensures all ko.observables, kb.observables, and the like to be properly released to avoid memory leaks.</p>
<p>That said, you can largely automate this using the approach from <a href="https://github.com/kmalakoff/knockback-navigators">Knockback-Navigators.js</a>!</p>
<p>Knockback-Navigators.js uses an implicit memory management model based on Knockback.js conventions (based on Knockout.js functionality). When an element is created, Knockback binds Knockout&#39;s dispose node callback:</p>
<pre><code>// binds a callback to the node that releases the view model when the node is removed using ko.removeNode
ko.utils.domNodeDisposal.addDisposeCallback(node, function() { kb.release(view_model)} );</code></pre>
<p>There are three ways to do this in Knockback:</p>
<pre><code>// Auto-released Template
var el = kb.renderTemplate(&#39;template_name&#39;, view_model, options);

// OR: When applying bindings
kb.applyBindings(view_model, el);

// OR: Manually
kb.releaseOnNodeRemove(view_model, el);</code></pre>
<h3>An example:</h3>
<p>In the reference application, I manually create the statistics view model:</p>
<pre><code>var statistics_el = kb.renderTemplate(&#39;statistics&#39;, new StatisticsViewModel());
$(&#39;body&#39;).append(statistics_el);
...
ko.releaseNode(statistics_el);</code></pre>
<p>Calling ko.releaseNode will not only clean up the element, but also call destroy() on the StatisticsViewModel.</p>
<h1>Routing</h1>
<p>Backbone.Router is quite easy to use with a Knockback. Here is a simple example where there can only be one active page at a time:</p>
<pre><code>window.RouterBackboneJS = Backbone.Router.extend({
  constructor: function(page_navigator) {
    var _this = this; // allow &#39;this&#39; inside of the callbacks

    Backbone.Router.prototype.constructor.apply(this, arguments);
    this.active_el = null;
    this.route(&#39;&#39;, null, function() {
      return _this.loadPage(kb.renderTemplate(&#39;home&#39;, {}));
    });

    this.route(&#39;things&#39;, null, function() {
      return _this.loadPage(kb.renderTemplate(&#39;things_page&#39;, new ThingsPageViewModel()));
    });

    this.route(&#39;things/:id&#39;, null, function(id) {
      var model = app.collections.things.get(id) || new Backbone.ModelRef(app.collections.things, id);
      return _this.loadPage(kb.renderTemplate(&#39;thing_page&#39;, new ThingCellViewModel(model)));
    });
  },

  loadPage: function(el) {
    // clean up both the element and the view model (see above discussion on memory management)
    if (this.active_el) {
      ko.removeNode(this.active_el);
    }
    $(&#39;.pane-navigator.page&#39;).append(this.active_el = el);
    $(el).addClass(&#39;active&#39;); // CSS {display: none} -&gt; {display: block}
  }
});</code></pre>
<h1>Advanced Routing</h1>
<p>You can use <a href="https://github.com/kmalakoff/knockback-navigators">Knockback-Navigators.js</a> to provide more exciting and interesting functionality. Here&#39;s an example with transitions and non-cached pages:</p>
<pre><code>window.RouterBackboneJSExtendedNoCache = Backbone.Router.extend({
  constructor: function(page_navigator /* instance of kb.PageNavigatorPanes */) {
    Backbone.Router.prototype.constructor.apply(this, arguments);

    this.route(&#39;&#39;, null, page_navigator.dispatcher(function() {
      return page_navigator.loadPage({
        create: function() { return kb.renderTemplate(&#39;home&#39;, {}); },
        transition: { name: &#39;FadeIn&#39;, duration: 1000 }
      });
    }));

    this.route(&#39;things&#39;, null, page_navigator.dispatcher(function() {
      return page_navigator.loadPage({
        create: function() { return kb.renderTemplate(&#39;things_page&#39;, new ThingsPageViewModel()); },
        transition: &#39;NavigationSlide&#39;
      });
    }));

    this.route(&#39;things/:id&#39;, null, page_navigator.dispatcher(function(id) {
      var model = app.collections.things.get(id) || new Backbone.ModelRef(app.collections.things, id);
      page_navigator.loadPage({
        create: function() { return kb.renderTemplate(&#39;thing_page&#39;, new ThingCellViewModel(model)); },
        transition: &#39;CoverVertical&#39;
      });
    }));
  });</code></pre>
<h1>Application Architecture</h1>
<p>I try to keep directories organized like in <a href="http://addyosmani.github.com/todomvc/">TodoMVC</a> and <a href="http://brunch.io/">Brunch</a>:</p>
<pre><code>- app
  - lib - reusable libraries
  - models - all your Backbone.Views and Backbone.Collections
  - view_models - all of your Knockout ViewModels
  - views - all of your HTML Views/Templates</code></pre>
<p>In the Knockback Reference Application, I did not want the complexity of an AMD loader so I added everything to the window:</p>
<pre><code>window.ThingLinkViewModel = kb.ViewModel.extend({
  constructor: function(model, options) {
    var _this = this;
    kb.ViewModel.prototype.constructor.call(this, model, {keys: [&#39;name&#39;, &#39;id&#39;], options: options});
    this.goTo = function() { return window.location.hash = &quot;#things/&quot; + (_this.id()); };
    return this;
  }
});</code></pre>
<p>If you are making a large app, you could create a single namespace like &#39;window.MyApp = {};&#39; to hang all of your classes from or you could use an AMD loading solution like <a href="">Brunch</a>.</p>
<h1>Walkthrough</h1>
<p>I will skip the extended application-specific code to keep things simple so you might see additional code in the actual application code.</p>
<h2>Application-Specific</h2>
<p>Like in Brunch, the appplication is managed using an Application class:</p>
<pre><code>window.Application = (function() {

  function Application() {
    _.bindAll(this, &#39;deleteAllThings&#39;, &#39;goToThings&#39;, &#39;setMode&#39;); // binding so can be called from Views

    // placeholders for all application shared data
    this.view_models = {};
    this.collections = {};
  }

  Application.prototype.initialize = function() {
    // start Backbone History
    Backbone.history || (Backbone.history = new Backbone.History());

    // set up collections
    this.collections.things = new ThingCollection();
    this.collections.things.fetch();
  };

  Application.prototype.goToThings = function() {
    return window.location.hash = &#39;things&#39;;
  };

  Application.prototype.deleteAllThings = function() {
    // create a copy or else will modifying the same models array as Backbone.Collection
    var models = _.clone(this.collections.things.models);
    for (var i = 0, len = models.length; i &lt; len; i++) {
      models[i].destroy();
    }
  };

  return Application;
})();</code></pre>
<h2>Models</h2>
<p>Thing Models use Backbone-Relational to manage ownership:</p>
<pre><code>window.Thing = Backbone.RelationalModel.extend({
  url: function() {
    return &quot;things/&quot; + (this.get(&#39;id&#39;));
  },
  relations: [
    {
      type: &#39;HasMany&#39;,
      key: &#39;my_things&#39;,
      includeInJSON: &#39;id&#39;,
      relatedModel: &#39;Thing&#39;,
      reverseRelation: {
        key: &#39;my_owner&#39;,
        includeInJSON: &#39;id&#39;
      }
    }
  ]
});</code></pre>
<p>These relationships are then editable using HTML select and kb.CollectionObservables:</p>
<p>View:</p>
<pre><code>&lt;select multiple=&quot;multiple&quot; data-bind=&quot;options: available_things, optionsText: &#39;name&#39;, selectedOptions: my_things_select&quot;&gt;&lt;/select&gt;</code></pre>
<p>ViewModel:</p>
<pre><code>window.ThingCellViewModel = kb.ViewModel.extend({
  constructor: function(model, options) {
    var _this = this;
    kb.ViewModel.prototype.constructor.call(this, model, {
      requires: [&#39;id&#39;, &#39;name&#39;, &#39;caption&#39;, &#39;my_things&#39;, &#39;my_owner&#39;],
      factories: {
        &#39;my_things&#39;: ThingCellCollectionObservable,
        &#39;my_owner&#39;: ThingLinkViewModel
      },
      options: options
    });

    this.my_things_select = ko.observableArray(this.my_things());

    this.available_things = new ThingCellCollectionObservable(app.collections.things, {
      filters: this.id, // exclude me from the list
      sort_attribute: &#39;name&#39;, // sort by name
      options: this.my_things.value().shareOptions() // Knockback needs to share the option ViewModels across collections: value() is needed to access the kb.CollectionObservable inside the kb.Observable
    });
  }
});

window.ThingCellCollectionObservable = kb.CollectionObservable.extend({
  constructor: function(collection, options) {
    // do not return &#39;this&#39; but the ko.observableArray created by the kb.CollectionObservable constructor
    return kb.CollectionObservable.prototype.constructor.call(this, collection, { view_model: ThingCellViewModel, options: options });
  }
});</code></pre>
<h1>Extended Features</h1>
<p>In addition to a the Tutorial reference application, you can find more advanced implementations that use <a href="https://github.com/kmalakoff/knockback-navigators">Knockback-Navigators.js</a> for page and embedded pane transitions (under DemoMode):</p>
<ul>
<li><strong>Panes</strong>: adds sliding panes with embedded cells for each relationship instead of simple buttons.</li>
<li><strong>Page Animations</strong>: adds transition animations without history when navigating between pages.</li>
<li><strong>Page Animations + History</strong>: adds transition animations with history when navigating between pages. Note: you can re-loading the page and the transitions will work as if you navigated from the main page.</li>
<li><strong>Page Animations + History + No Cache</strong>: when you use history, you need to be careful to not keep too many pages in memory. This example show you how to on-demand load pages by passing a create function instead of element to the page navigator.</li>
</ul>
<p>To help verify correct memory management and performance, the reference application provides some statistics helpers (under DemoMode -&gt; Statistics):</p>
<ul>
<li><strong>Chrome memory heap statistics</strong>: You need to launch Chrome with the --enable-memory-info flag and also you might need to trigger heap compaction to ensure the statistics are up-to-date (for example, by using Developer Tools -&gt; Profiles -&gt; Take Heap Snapshot).</li>
<li><strong>Active ViewModels/CollectionObservables</strong>: using the Knockback.js statistics component, you can see what which ViewModels and CollectionObservables are in memory. Note: if you do not derive from kb.ViewModel or kb.CollectionObservable, you need to add them manually using kb.Statistics.register(key, obj)</li>
<li><strong>Backbone.Model Events</strong>: using the Knockback.js statistics component, you can see and reset all of the events that Knockback.js has intercepted from Backbone.js</li>
<li><strong>Page Cycling</strong>: to do soak testing, you can choose the number of randomized page cycles and time per page to see the memory characteristics over time.</li>
</ul>

        </section>
      </content>
      <footer class="page">
      </footer>
    </div>
  </body>
</html>